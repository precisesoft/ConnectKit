#!/usr/bin/env node

/**
 * Enhanced Vulnerability Checker for ConnectKit
 * Performs comprehensive vulnerability analysis with configurable thresholds
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class VulnerabilityChecker {
  constructor() {
    this.severityThreshold = process.env.SEVERITY_THRESHOLD || 'medium';
    this.allowlist = this.loadAllowlist();
    this.results = {
      total: 0,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      exceptions: 0,
      filtered: 0,
    };
  }

  loadAllowlist() {
    try {
      const allowlistPath = '.sbom/allowlist.json';
      if (!fs.existsSync(allowlistPath)) {
        console.warn('‚ö†Ô∏è Vulnerability allowlist not found, creating default');
        this.createDefaultAllowlist();
      }
      return JSON.parse(fs.readFileSync(allowlistPath, 'utf8'));
    } catch (error) {
      console.warn(
        '‚ö†Ô∏è Could not load vulnerability allowlist, using strict mode:',
        error.message
      );
      return {
        vulnerabilities: { exceptions: [], temporary_exceptions: [] },
        thresholds: {
          critical: { max_allowed: 0, fail_build: true },
          high: { max_allowed: 0, fail_build: true },
          medium: { max_allowed: 10, fail_build: false },
          low: { max_allowed: 50, fail_build: false },
        },
      };
    }
  }

  createDefaultAllowlist() {
    const defaultAllowlist = {
      vulnerabilities: { 
        exceptions: [], 
        temporary_exceptions: [] 
      },
      thresholds: {
        critical: { max_allowed: 0, fail_build: true, notify: true },
        high: { max_allowed: 0, fail_build: true, notify: true },
        medium: { max_allowed: 10, fail_build: false, notify: true },
        low: { max_allowed: 50, fail_build: false, notify: false },
      },
    };

    // Ensure directory exists
    if (!fs.existsSync('.sbom')) {
      fs.mkdirSync('.sbom', { recursive: true });
    }

    fs.writeFileSync(
      '.sbom/allowlist.json',
      JSON.stringify(defaultAllowlist, null, 2)
    );
    console.log('‚úÖ Created default vulnerability allowlist');
  }

  isVulnerabilityException(cve) {
    const exceptions = [
      ...this.allowlist.vulnerabilities.exceptions,
      ...this.allowlist.vulnerabilities.temporary_exceptions,
    ];

    const exception = exceptions.find((ex) => ex.cve === cve);
    if (!exception) return false;

    // Check if exception is still valid
    if (exception.expires) {
      const expiryDate = new Date(exception.expires);
      if (new Date() > expiryDate) {
        console.warn(
          `‚ö†Ô∏è Exception for ${cve} has expired (${exception.expires})`,
        );
        return false;
      }
    }

    console.log(`‚úÖ Exception applied for ${cve}: ${exception.reason}`);
    return true;
  }

  analyzeSeverityThreshold(severity) {
    const levels = ['low', 'medium', 'high', 'critical'];
    const thresholdIndex = levels.indexOf(this.severityThreshold);
    const severityIndex = levels.indexOf(severity.toLowerCase());

    return severityIndex >= thresholdIndex;
  }

  processVulnerabilities(vulnFilePath) {
    if (!fs.existsSync(vulnFilePath)) {
      console.error(`‚ùå Vulnerability file not found: ${vulnFilePath}`);
      return false;
    }

    const vulnData = JSON.parse(fs.readFileSync(vulnFilePath, 'utf8'));

    if (!vulnData.matches || vulnData.matches.length === 0) {
      console.log('‚úÖ No vulnerabilities found');
      return true;
    }

    this.results.total = vulnData.matches.length;
    const filteredVulns = [];

    console.log(
      `\\nüîç Processing ${this.results.total} vulnerability findings...`,
    );
    console.log(`üìä Severity threshold: ${this.severityThreshold}`);

    vulnData.matches.forEach((match) => {
      const cve = match.vulnerability.id;
      const severity = match.vulnerability.severity.toLowerCase();
      const component = match.artifact.name;
      const version = match.artifact.version;

      // Count by severity
      this.results[severity]++;

      // Check if above threshold
      if (this.analyzeSeverityThreshold(severity)) {
        // Check allowlist
        if (this.isVulnerabilityException(cve)) {
          this.results.exceptions++;
        } else {
          filteredVulns.push({
            cve,
            severity,
            component,
            version,
            description: match.vulnerability.description,
            urls: match.vulnerability.dataSource || [],
          });
          this.results.filtered++;
        }
      }
    });

    // Save filtered results
    const filteredData = {
      metadata: {
        original_count: this.results.total,
        filtered_count: this.results.filtered,
        exceptions_applied: this.results.exceptions,
        severity_threshold: this.severityThreshold,
        processed_at: new Date().toISOString(),
      },
      vulnerabilities: filteredVulns,
      summary: this.results,
    };

    fs.writeFileSync(
      'sbom-output/vulnerabilities-filtered.json',
      JSON.stringify(filteredData, null, 2),
    );

    this.printSummary();
    return this.evaluateThresholds();
  }

  printSummary() {
    console.log(`\\nüìä Vulnerability Summary:`);
    console.log(`   Total found: ${this.results.total}`);
    console.log(`   Critical: ${this.results.critical}`);
    console.log(`   High: ${this.results.high}`);
    console.log(`   Medium: ${this.results.medium}`);
    console.log(`   Low: ${this.results.low}`);
    console.log(`   Exceptions applied: ${this.results.exceptions}`);
    console.log(
      `   Above threshold (${this.severityThreshold}): ${this.results.filtered}`,
    );
  }

  evaluateThresholds() {
    const thresholds = this.allowlist.thresholds;
    let shouldFail = false;
    const failures = [];

    console.log(`\\nüéØ Evaluating against configured thresholds:`);

    Object.entries(this.results).forEach(([severity, count]) => {
      if (['critical', 'high', 'medium', 'low'].includes(severity)) {
        const threshold = thresholds[severity];
        if (threshold) {
          const exceeds = count > threshold.max_allowed;
          const failBuild = threshold.fail_build && exceeds;

          console.log(
            `   ${severity.padEnd(8)}: ${count.toString().padStart(3)} / ${threshold.max_allowed.toString().padStart(3)} allowed ${exceeds ? '‚ùå' : '‚úÖ'} ${failBuild ? '(FAIL)' : ''}`,
          );

          if (failBuild) {
            shouldFail = true;
            failures.push({
              severity,
              count,
              threshold: threshold.max_allowed,
            });
          }
        }
      }
    });

    if (shouldFail) {
      console.log(`\\n‚ùå Build should fail due to threshold violations:`);
      failures.forEach((failure) => {
        console.log(
          `   ${failure.severity.toUpperCase()}: ${failure.count} found, max allowed: ${failure.threshold}`,
        );
      });
      return false;
    } else {
      console.log(`\\n‚úÖ All vulnerability thresholds passed`);
      return true;
    }
  }

  generateVEXDocument() {
    console.log(
      'üìÑ Generating VEX (Vulnerability Exploitability eXchange) document...',
    );

    const vexDocument = {
      '@context': 'https://openvex.dev/ns/v0.2.0',
      '@id': `https://connectkit.com/vex/${new Date().toISOString().split('T')[0]}`,
      author: 'ConnectKit Security Team',
      timestamp: new Date().toISOString(),
      version: 1,
      statements: [],
    };

    // Add statements for exceptions
    this.allowlist.vulnerabilities.exceptions.forEach((exception) => {
      vexDocument.statements.push({
        vulnerability: {
          name: exception.cve,
        },
        products: [
          {
            '@id': 'pkg:npm/connectkit@1.0.0',
          },
        ],
        status: 'not_affected',
        justification: 'vulnerable_code_not_in_execute_path',
        impact_statement: exception.reason,
      });
    });

    // Add temporary exceptions
    this.allowlist.vulnerabilities.temporary_exceptions.forEach((exception) => {
      vexDocument.statements.push({
        vulnerability: {
          name: exception.cve,
        },
        products: [
          {
            '@id': 'pkg:npm/connectkit@1.0.0',
          },
        ],
        status: 'under_investigation',
        impact_statement: exception.reason,
        action_statement: `Remediation planned before ${exception.expires}`,
      });
    });

    fs.writeFileSync(
      'sbom-output/vex-document.json',
      JSON.stringify(vexDocument, null, 2),
    );

    console.log('‚úÖ VEX document generated');
  }

  async run() {
    try {
      console.log('üîê Starting Enhanced Vulnerability Analysis for ConnectKit');

      // Check if SBOM file exists
      const sbomFile = 'sbom-output/sbom-cyclonedx.json';
      if (!fs.existsSync(sbomFile)) {
        console.error(`‚ùå SBOM file not found: ${sbomFile}`);
        console.log('üí° Run SBOM generation first: npm run sbom:generate');
        process.exit(1);
      }

      // Run Grype scan
      console.log('üîç Running vulnerability scan with Grype...');
      try {
        execSync(
          `grype ${sbomFile} -o json > sbom-output/vulnerabilities-raw.json`,
          { stdio: 'inherit' },
        );
      } catch (error) {
        // Grype returns non-zero when vulnerabilities found, but that's expected
        console.log('üìä Vulnerability scan completed');
      }

      // Process results
      const passed = this.processVulnerabilities(
        'sbom-output/vulnerabilities-raw.json',
      );

      // Generate VEX document
      this.generateVEXDocument();

      if (!passed) {
        console.log('\\n‚ùå Vulnerability check failed - thresholds exceeded');
        process.exit(1);
      } else {
        console.log('\\n‚úÖ Vulnerability check passed');
      }
    } catch (error) {
      console.error('‚ùå Vulnerability check failed:', error.message);
      process.exit(1);
    }
  }
}

// CLI argument parsing
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
ConnectKit Vulnerability Checker

Usage: node vulnerability-check.js [options]

Options:
  --severity-threshold <level>  Set minimum severity level (low|medium|high|critical)
  --help, -h                   Show this help message

Environment Variables:
  SEVERITY_THRESHOLD           Minimum severity level to report
  
Examples:
  node vulnerability-check.js --severity-threshold high
  SEVERITY_THRESHOLD=critical node vulnerability-check.js
        `);
    process.exit(0);
  }

  // Parse arguments
  const severityIndex = args.indexOf('--severity-threshold');
  if (severityIndex !== -1 && args[severityIndex + 1]) {
    process.env.SEVERITY_THRESHOLD = args[severityIndex + 1];
  }

  const checker = new VulnerabilityChecker();
  checker.run();
}

module.exports = VulnerabilityChecker;
